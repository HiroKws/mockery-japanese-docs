::: index
single: Cookbook; オリジナルのコンストラクターを呼び出さない
:::

# オリジナルのコンストラクターを呼び出さない

生成パーシャルテストダブルを生成するとき、Mockeryは指定されたメソッドのみをモックします。つまり、モックしているクラスのオリジナルなコンストラクターが呼び出されることを意味しています。

あるケースではこの振る舞いを望まないでしょう。コンストラクターは他のメソッドや関連しているオブジェクトを呼び出すかもしれませんし、それによりテスト実行時のアプリケーション環境では望まない副作用を起こしてしまう可能性があります。

これが起きた場合、オリジナルのコンストラクターが呼び出されないように、ランタイムパーシャルテストダブルを使用する必要があります。

``` php
class MyClass
{
    public function __construct()
    {
        echo "Original constructor called." . PHP_EOL;
        // 他の副作用が起きる可能性がある…
    }
}

// これにより、"Original constructor called."が出力される
$mock = \Mockery::mock('MyClass[foo]');
```

よりよりアプローチは、ランタイムパーシャルダブルを使用します。

``` php
class MyClass
{
    public function __construct()
    {
        echo "Original constructor called." . PHP_EOL;
        // 他の副作用が起きる可能性がある…
    }
}

// これなら、何も出力されない
$mock = \Mockery::mock('MyClass')->makePartial();
$mock->shouldReceive('foo');
```

生成パーシャルテストダブルの使用を推奨していないのは、これが理由の一つです。可能であれば、常にランタイムパーシャルを使用してください。

[パーシャルテストダブル](creating_test_doubles.htm#パーシャルテストダブル)については、詳細ページをご覧ください。

> {note}
> 生成パーシャルテストダブルが役立つのは、互換性です。とても古いバージョンのMockeryを使用する場合、生成パーシャルではコンストラクターを呼び出さない振る舞いをしていました。Mockeryをより新しいバージョンへアップグレードしている場合は、生成パーシャルの代わりに、ランタイムパーシャルをテストで使用するように変更する必要があるでしょう。
>
> この変更は、２０１３年の初頭に導入されました。それより前のMockeryを使用しているのでしたら、この問題は起きません。
